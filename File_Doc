# Multi‑Stage Docker Build Demo

A portfolio‑ready, senior‑level demo showing the difference between **single‑stage** and **multi‑stage** Docker builds for a tiny Java app. Includes: step‑by‑step commands, secure Dockerfiles, Makefile, CI workflow, and a creative README you can publish directly on GitHub.

---

## 0) Prerequisites

* Docker 24+ (BuildKit enabled by default)
* Git, GitHub account
* (Optional) Java/Maven locally — not required because we build in Docker

---

## 1) Repo layout (copy as‑is)

```
multi-stage-docker-demo/
├─ src/main/java/com/example/HelloApp.java
├─ pom.xml
├─ Dockerfile              # multi-stage (production)
├─ Dockerfile.single       # single-stage (naïve)
├─ .dockerignore
├─ .gitignore
├─ Makefile
├─ LICENSE
└─ .github/workflows/ci.yml
```

---

## 2) Files

### `src/main/java/com/example/HelloApp.java`

```java
package com.example;

public class HelloApp {
    public static void main(String[] args) {
        System.out.println("Hello Abdallah, Welcome to DevOps Industry!");
    }
}
```

---

### `pom.xml`

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>hello-app</artifactId>
    <version>1.0-SNAPSHOT</version>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>17</source>
                    <target>17</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-assembly-plugin</artifactId>
                <version>3.6.0</version>
                <configuration>
                    <archive>
                        <manifest>
                            <mainClass>com.example.HelloApp</mainClass>
                        </manifest>
                    </archive>
                    <descriptorRefs>
                        <descriptorRef>jar-with-dependencies</descriptorRef>
                    </descriptorRefs>
                </configuration>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>single</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
```

---

### `Dockerfile` (multi‑stage, production‑ready)

```dockerfile
# syntax=docker/dockerfile:1.7

# ---------- Stage 1: Build ----------
FROM maven:3.9.6-eclipse-temurin-17 AS build
WORKDIR /app
COPY pom.xml .
COPY src ./src
# Build the fat JAR (skip tests for speed). Add --no-transfer-progress for quieter logs
RUN mvn -q -DskipTests --no-transfer-progress clean package

# ---------- Stage 2: Runtime ----------
FROM eclipse-temurin:17-jre
ARG VCS_REF
ARG BUILD_DATE
LABEL org.opencontainers.image.title="Multi-Stage Docker Build Demo" \
      org.opencontainers.image.description="Demo of single-stage vs multi-stage Docker builds for Java" \
      org.opencontainers.image.source="https://github.com/<your-username>/multi-stage-docker-demo" \
      org.opencontainers.image.revision=$VCS_REF \
      org.opencontainers.image.created=$BUILD_DATE

# Create non-root user (security hardening)
RUN groupadd -g 10001 app && useradd -r -u 10001 -g app app
WORKDIR /app
COPY --from=build --chown=10001:10001 /app/target/hello-app-1.0-SNAPSHOT-jar-with-dependencies.jar /app/app.jar
USER 10001

# No shell tools installed -> smaller attack surface
CMD ["java", "-jar", "app.jar"]
```

> Notes:
>
> * Runs as non‑root (UID 10001).
> * Uses OCI labels so registries show nice metadata.

---

### `Dockerfile.single` (single‑stage, big & less secure)

```dockerfile
FROM maven:3.9.6-eclipse-temurin-17
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn -q -DskipTests --no-transfer-progress clean package
CMD ["java", "-jar", "target/hello-app-1.0-SNAPSHOT-jar-with-dependencies.jar"]
```

---

### `.dockerignore`

```gitignore
# Keep build context lean
.git
.github
.idea
.vscode
.DS_Store
**/target
```

---

### `.gitignore`

```gitignore
# Java / Maven
target/
*.log
*.iml
.idea/
.vscode/
.DS_Store
```

---

### `Makefile` (quality of life)

```makefile
APP=hello
IMAGE_MULTI=$(APP)-multi
IMAGE_SINGLE=$(APP)-single

.PHONY: build-multi run-multi build-single run-single size clean

build-multi:
	docker build -t $(IMAGE_MULTI) -f Dockerfile .

run-multi:
	docker run --rm $(IMAGE_MULTI)

build-single:
	docker build -t $(IMAGE_SINGLE) -f Dockerfile.single .

run-single:
	docker run --rm $(IMAGE_SINGLE)

size:
	docker images | grep $(APP)

clean:
	-@docker rmi $(IMAGE_MULTI) $(IMAGE_SINGLE) 2>/dev/null || true
```

---

### `.github/workflows/ci.yml` (build, assert output, compare sizes)

```yaml
name: CI

on:
  push:
  pull_request:

jobs:
  build-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build multi-stage image (load to local)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          tags: hello-multi:ci
          load: true
          build-args: |
            VCS_REF=${{ github.sha }}
            BUILD_DATE=${{ github.event.head_commit.timestamp || github.run_started_at }}

      - name: Build single-stage image (load to local)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile.single
          tags: hello-single:ci
          load: true

      - name: Assert output is correct (multi)
        run: |
          set -e
          OUT=$(docker run --rm hello-multi:ci)
          echo "$OUT"
          test "$OUT" = "Hello Abdallah, Welcome to DevOps Industry!"

      - name: Assert output is correct (single)
        run: |
          set -e
          OUT=$(docker run --rm hello-single:ci)
          echo "$OUT"
          test "$OUT" = "Hello Abdallah, Welcome to DevOps Industry!"

      - name: Verify container runs as non-root (multi)
        run: |
          USER=$(docker inspect -f '{{.Config.User}}' hello-multi:ci)
          echo "Image user: $USER"
          test "$USER" = "10001"

      - name: Show image sizes
        run: |
          docker images | grep hello
```

---

### `LICENSE` (MIT)

```text
MIT License

Copyright (c) 2025 Abdallah Saleh

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

---

## 3) Creative README (paste into `README.md`)

````markdown
# 🚀 Multi‑Stage Docker Build — From Zero to Pro

> A tiny Java app packaged two ways to **prove** why multi‑stage builds win: smaller images, fewer CVEs, safer runtime. This repo is intentionally simple and highly opinionated so you can reuse it in interviews, demos, and onboarding.

![status-badge](https://img.shields.io/badge/build-passing-brightgreen)

---

## TL;DR
```bash
make build-multi && make run-multi   # ✅ production way
make build-single && make run-single # ❌ naïve way
make size                            # compare sizes
````

Expected output at runtime:

```
Hello Abdallah, Welcome to DevOps Industry!
```

---

## Why this repo?

* **See the difference** between single‑stage and multi‑stage using the exact same code.
* **Security by default**: final image runs as non‑root and contains only the JRE + your JAR.
* **CI built‑in**: GitHub Actions builds both images, asserts output, and verifies UID ≠ 0.

---

## Project structure

```
.
├─ src/main/java/com/example/HelloApp.java
├─ pom.xml
├─ Dockerfile          # multi-stage (production)
├─ Dockerfile.single   # single-stage (naïve)
├─ .dockerignore
├─ .gitignore
├─ Makefile
└─ .github/workflows/ci.yml
```

---

## Quickstart (copy‑paste)

```bash
# 1) Clone or create the folder
mkdir -p multi-stage-docker-demo && cd $_

# 2) Create files (or copy from this repo)
# ... files already in repo ...

# 3) Build & run — multi‑stage
make build-multi
make run-multi

# 4) Build & run — single‑stage
make build-single
make run-single

# 5) Compare sizes
make size
```

---

## What’s the real difference?

| Topic            | Single‑Stage Build ❌             | Multi‑Stage Build ✅        |
| ---------------- | -------------------------------- | -------------------------- |
| Final size       | Big (keeps Maven + caches)       | Small (only runtime + app) |
| Attack surface   | Larger (compilers, shells, etc.) | Minimal (no build tools)   |
| Runtime user     | root (default)                   | non‑root (UID 10001)       |
| Production ready | No                               | Yes                        |

> Rule of thumb: fewer packages → fewer CVEs → faster pulls → cheaper storage.

---

## Security notes

* Final image uses a **non‑root** user.
* No package managers/compilers in runtime stage.
* `.dockerignore` keeps the build context lean (less to leak).
* Consider switching runtime to **distroless** for even fewer binaries.

### Optional (local) hardening

```bash
# SBOM (requires anchore/syft)
syft hello-multi:latest > sbom.txt

# Vulnerability scan (requires aquasecurity/trivy)
trivy image hello-multi:latest
```

---

## CI/CD

* Workflow builds both images on every push/PR.
* Asserts the printed output matches exactly.
* Verifies the image runs as user **10001**.

> Add a status badge after you push:

```
![ci](https://github.com/<your-username>/multi-stage-docker-demo/actions/workflows/ci.yml/badge.svg)
```

---

## FAQ

**Q: Why not just use a single‑stage build?**
A: It works, but ships unnecessary tools → bigger, less secure images.

**Q: Can I use Alpine or distroless?**
A: Yes. Distroless + non‑root is a great upgrade for production.

**Q: Do I need Maven locally?**
A: No. The build happens inside Docker.

---

## Contributing

PRs welcome. Keep it minimal, reproducible, and beginner‑friendly.

## License

MIT — see `LICENSE`.

````

---

## 4) Step‑by‑step: initialize Git & push to GitHub
> Replace `<your-username>` with your GitHub handle.

```bash
# From inside the project folder
git init
git add .
git commit -m "feat: multi-stage docker demo (secure & small)"

# Create the repo on GitHub (via UI) named: multi-stage-docker-demo
# Then add the remote and push

git branch -M main
git remote add origin https://github.com/<your-username>/multi-stage-docker-demo.git
git push -u origin main
````

After the push, open **Actions** tab to watch the CI run. Add the badge line from the README (replace `<your-username>` once your repo exists).

---

## 5) Next steps (level‑up ideas)

* Switch runtime to **gcr.io/distroless/java17-debian12** and keep `USER nonroot`.
* Add `hadolint` checks for the Dockerfiles.
* Add integration tests (e.g., assert exit code & logs).
* Build multi‑arch images with Buildx (`linux/amd64, linux/arm64`).
* Tag releases (e.g., `v1.0.0`) and attach SBOM as artifact.

---

**You’re set.** This is a clean, interview‑grade demo that shows you know Docker fundamentals *and* production hardening best practices.

